# -*- mode: sh; sh-shell: bash; coding: utf-8; -*-

start-color () { echo -n -e "\e[${1}m"; }
reset-color () { echo -n -e "\e[0m"; }
colored () { start-color "${1}"; echo -n "${2}"; reset-color; }
error   () { colored 91 "[ERROR]";   echo -e ": ${1}"; }
warning () { colored 33 "[WARNING]"; echo -e ": ${1}"; }
note    () { colored 94 "[NOTE]";    echo -e ": ${1}"; }
bold    () { start-color 1; echo -n "${1}"; reset-color; }
ulin    () { start-color 4; echo -n "${1}"; reset-color; }

if [[ "${BASH_SOURCE[0]}" = "${0}" ]] || [[ "${_}" = "${0}" ]]; then
    error "Don't execute this file; instead source it into your shell."
    exit 1
fi

fast-reset () {
    echo -e '\0033\0143'
}

surround () {
    cat <(echo -n "${1}") - <(echo -n "${2}")
}

resolve-paths () {
    parallel 'exists () { [ -e "$1" ] && readlink -f "$1"; }; exists {};'
}

remove-store-paths () {
    sed -r 's|/nix/store/[[:alnum:]]{32}-|nix://|g';
}

shorten-pwd () {
    sed "s|$(pwd)|pwd://|g"
}

build-plugin () {
    build-cmd () {
        make |& cat
    }

    build-output-filters () {
        cat - \
            | remove-store-paths \
            | shorten-pwd
    }

    export PAGER
    PAGER="less"

    while (( $# > 1 )); do
        export key="${1}"
        case "$key" in
            -p|--pager)
                PAGER="${2}"
                shift 1
                ;;
            -n|--no-pager)
                export PAGER=""
                ;;
        esac
        shift 1
    done

    if [[ -n "${PAGER}" ]]; then
        build-cmd \
            | build-output-filters \
            | ${PAGER}
    else
        build-cmd |& build-output-filters
    fi
}

code-block () {
    pygmentize -l "${1}" | sed 's|^|    |g' | surround '\n' '\n'
}

enquote-all-lines () {
    sed 's/^/"/g; s/$/"/g;'
}

pretty-print-sexpr () {
    guile -c "(use-modules (ice-9 pretty-print)) (pretty-print (read))"
}

check-trailing-whitespace () {
    usage () {
        echo "Usage: check-trailing-whitespace [OPTION]..."
        echo ""
        echo "$(bold '-h'), $(bold '--help')       Display this help message"
        echo "$(bold '-j'), $(bold '--jobs') NUM   Use NUM jobs in parallel"
        echo "$(bold '-c'), $(bold '--null')       Assume NUL-separated input"
        echo ""
        echo "Each file name received via stdin will be checked for trailing"
        echo "whitespace. If it contains trailing whitespace, the path will"
        echo "be printed. Otherwise, it will not."
    }

    local NULL_FLAG JOBS_FLAG
    NULL_FLAG=""
    JOBS_FLAG=""

    while (( $# > 1 )); do
        export key="${1}"
        case "$key" in
            -h|--help)
                usage
                return 255
                ;;
            -0|--null)
                NULL_FLAG="-0"
                ;;
            -j|--jobs)
                [[ "${2}" =~ '^[0-9]+$' ]] || { usage; return 1; }
                JOBS_FLAG="-j ${2}"
                shift 1
                ;;
        esac
        shift 1
    done

    search-file () {
        egrep -ls '^.*[[:space:]]+$' "${1}" | sort -u || return 0
    }

    PARALLEL_ENV="$(typeset -f search-file)";
    export PARALLEL_ENV

    parallel-cmd () {
        eval "parallel ${JOBS_FLAG} ${NULL_FLAG} ${*}"
    }

    parallel-cmd -- 'search-file {};' || { usage; return 2; }
}

git-list-non-ignored-files () {
    {
        git ls-files
        git ls-files . --exclude-standard --others
    } | sort -u
}

git-trailing-whitespace-check () {
    git-list-non-ignored-files | check-trailing-whitespace
}

generate-emacs-include-path () {
    if (( $# != 1 )) || [[ ! -f "$1" ]]; then
        echo "This function takes a single argument, which is a file."
        echo "This file (named 'build-log.input') can be generated by running"
        echo "the following commands:"
        {
            echo "# Make sure you are in the repository root."
            echo "# Then, enter a nix-shell and do the following inside it."
            echo "cd plugin"
            echo "alias cmakeConf='cmakeConfigurePhase'"
            echo "cmakeFlags=\"-DCMAKE_CXX_FLAGS=-v \$cmakeFlags\" \\"
            echo "    cmakeConfigurePhase"
            echo "make &> ../../build-log.input"
        } | code-block bash
    else
        CLANG_BEGIN_QUOTE_SEARCH='#include "..." search starts here:'
        CLANG_BEGIN_ANGLE_SEARCH='#include <...> search starts here:'
        CLANG_END_SEARCH='End of search list.'
        cat "${1}" \
            | sed -e "s/^${CLANG_BEGIN_QUOTE_SEARCH}\$/###START###/g;" \
                  -e "/^${CLANG_BEGIN_ANGLE_SEARCH}\$/d;" \
                  -e "s/^${CLANG_END_SEARCH}\$/###END###/g;" \
                  -e '1,/###START###/d;' \
                  -e '/###END###/,$d;' \
                  -e '/###\(START\|END\)###/d;' \
                  -e 's/^ //g;' \
            | resolve-paths \
            | enquote-all-lines \
            | tr '\n' ' ' \
            | surround '(progn (setq flycheck-clang-include-path (quote (' \
                       '))) (setq flycheck-clang-args (quote ("-fPIC"))))' \
            | pretty-print-sexpr
    fi
}

PROJECT_BUILD_ROOT="/home/remy/Documents/NotWork/Projects/Nix/pianoman/"

refresh-plugin-build () {
    if [[ -n "${1}" ]]; then
        cd "${1}" || exit
    else
        cd "${PROJECT_BUILD_ROOT}/plugin" || exit
    fi

    rm -rf build
    cmakeConfigurePhase
}

text-in-set () {
    usage () {
        echo "Usage: text-in-set TEXT -- SET_ELEMENTS..."
        echo ""
        echo "Check if TEXT is among the given SET_ELEMENTS."
    }

    (( $# >= 3 ))       || { usage; return 1; }
    [[ "${2}" = "--" ]] || { usage; return 2; }

    local INPUT="${1}"
    shift 2

    for a in "$@"; do
        [[ "${LC_INPUT}" = "${a}" ]] && return 0
    done

    return 255
}

ci-text-in-set () {
    usage () {
        echo "Usage: ci-text-in-set TEXT -- SET_ELEMENTS..."
        echo ""
        echo "Check if TEXT is among the given SET_ELEMENTS,"
        echo "case-insensitively."
    }

    (( $# >= 3 ))       || { usage; return 1; }
    [[ "${2}" = "--" ]] || { usage; return 2; }

    local INPUT="${1}"
    shift 2
    REST="${*}"

    LC_INPUT="$(echo "${INPUT}" | tr '[:upper:]' '[:lower:]')"

    eval "text-in-set '${INPUT}' -- ${REST}"
    return "$?"
}

text-represents-yes () {
    local -a ACCEPTABLE
    ACCEPTABLE=("y" "yes" "ye" "yea" "yeah")
    ci-text-in-set "${1}" -- "${ACCEPTABLE[@]}"
    return "$?"
}

text-represents-no () {
    local -a ACCEPTABLE
    ACCEPTABLE=("n" "no" "nope" "never")
    ci-text-in-set "${1}" -- "${ACCEPTABLE[@]}"
    return "$?"
}

enter-nix-shell () {
    if [[ "${IN_NIX_SHELL}" != "1" ]]; then
        nix-shell "${PROJECT_BUILD_ROOT}/build.nix" -A "${1}"
    else
        error "You are already in a nix-shell!"
    fi
}

commit () {
    (( $# == 1 )) || echo "Not enough arguments!"
    git commit -m "${1}" && git pull --rebase && git push
}

note "Helpers successfully loaded."
